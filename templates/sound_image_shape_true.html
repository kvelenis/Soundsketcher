


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Shape + Texture Sliders</title>
  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      background: #fefefe;
      font-family: sans-serif;
    }
    canvas {
      border: 1px solid #ccc;
      margin: 20px 0;
      background: white;
    }
    input[type="range"] {
      width: 300px;
    }
    .section {
      margin-bottom: 40px;
      display: flex;
      flex-direction: column;
    }
  </style>
</head>
<body>

  <!-- SECTION 1: SHAPE SLIDER (from previous code) -->
  <div class="section">
    <h2>Shape Smoothness Slider</h2>
    <input type="range" min="0" max="100" value="0" id="shapeSlider" />
    <canvas id="shapeCanvas" width="600" height="600"></canvas>
  </div>

<script>
// ========== SHAPE CODE (No change from earlier) ==========
const shapeCanvas = document.getElementById('shapeCanvas');
const shapeCtx = shapeCanvas.getContext('2d');
const shapeSlider = document.getElementById('shapeSlider');
const shapeW = shapeCanvas.width;
const shapeH = shapeCanvas.height;

function drawShape(val) {
    shapeCtx.clearRect(0, 0, shapeW, shapeH);
    const cx = shapeW / 2;
    const cy = shapeH / 2;
    const baseR = 130;
    const t = val / 100;

    const numTeeth = 20;
    shapeCtx.beginPath();

    if (t <= 0.5) {
    const progress = t / 0.5;
    const toothDepth = 30;
    const innerR = baseR + toothDepth * (1 - progress);
    const toothWidth = 0.2;
    const curveProgress = 1 - Math.min(1, progress / 0.8); // lasts until t ≈ 0.4


    let first = true;

    for (let i = 0; i < numTeeth; i++) {
      const angleStart = (Math.PI * 2 * i) / numTeeth;
      const angleTip1 = angleStart + (Math.PI * 2 / numTeeth) * toothWidth;
      const angleTip2 = angleStart + (Math.PI * 2 / numTeeth) * (1 - toothWidth);
      const angleEnd = (Math.PI * 2 * (i + 1)) / numTeeth;

      const p1 = {
        x: cx + innerR * Math.cos(angleStart),
        y: cy + innerR * Math.sin(angleStart)
      };
      const p2 = {
        x: cx + (baseR + toothDepth) * Math.cos(angleTip1),
        y: cy + (baseR + toothDepth) * Math.sin(angleTip1)
      };
      const p3 = {
        x: cx + (baseR + toothDepth) * Math.cos(angleTip2),
        y: cy + (baseR + toothDepth) * Math.sin(angleTip2)
      };
      const p4 = {
        x: cx + innerR * Math.cos(angleEnd),
        y: cy + innerR * Math.sin(angleEnd)
      };

      if (first) {
        shapeCtx.moveTo(p1.x, p1.y);
        first = false;
      }

      if (curveProgress > 0.01) {
        // control point between inner → outer
        const cp0 = {
          x: p1.x + (p2.x - p1.x) * curveProgress,
          y: p1.y + (p2.y - p1.y) * curveProgress
        };
        // control between outer corners
        const cp1 = {
          x: p2.x + (p3.x - p2.x) * curveProgress,
          y: p2.y + (p3.y - p2.y) * curveProgress
        };
        // control between outer → inner
        const cp2 = {
          x: p3.x + (p4.x - p3.x) * curveProgress,
          y: p3.y + (p4.y - p3.y) * curveProgress
        };

        shapeCtx.quadraticCurveTo(p2.x, p2.y, cp1.x, cp1.y);
        shapeCtx.quadraticCurveTo(p3.x, p3.y, cp2.x, cp2.y);
        shapeCtx.quadraticCurveTo(p4.x, p4.y, p4.x, p4.y);
      } else {
        // Fully sharp gear
        shapeCtx.lineTo(p2.x, p2.y);
        shapeCtx.lineTo(p3.x, p3.y);
        shapeCtx.lineTo(p4.x, p4.y);
      }
    }
  }
  else {
    // === SPIKY PHASE: triangle tips morphing (no height growth)
    const spikeProgress = (t - 0.5) / 0.5;
    const toothDepth = 30;
    const toothWidth = 0.15;

    let first = true;

    for (let i = 0; i < numTeeth; i++) {
      const angleStart = (Math.PI * 2 * i) / numTeeth;
      const angleMid1 = angleStart + (Math.PI * 2 / numTeeth) * toothWidth;
      const angleMid2 = angleStart + (Math.PI * 2 / numTeeth) * (1 - toothWidth);
      const angleEnd = (Math.PI * 2 * (i + 1)) / numTeeth;

      const p1 = {
        x: cx + baseR * Math.cos(angleStart),
        y: cy + baseR * Math.sin(angleStart)
      };
      const p4 = {
        x: cx + baseR * Math.cos(angleEnd),
        y: cy + baseR * Math.sin(angleEnd)
      };

      const tipLeft = {
        x: cx + (baseR + toothDepth) * Math.cos(angleMid1),
        y: cy + (baseR + toothDepth) * Math.sin(angleMid1)
      };
      const tipRight = {
        x: cx + (baseR + toothDepth) * Math.cos(angleMid2),
        y: cy + (baseR + toothDepth) * Math.sin(angleMid2)
      };

      const angleTip = (angleStart + angleEnd) / 2;
      const bladeTip = {
        x: cx + (baseR + toothDepth) * Math.cos(angleTip),
        y: cy + (baseR + toothDepth) * Math.sin(angleTip)
      };

      // Interpolate tipLeft → bladeTip, tipRight → bladeTip
      const p2 = {
        x: tipLeft.x * (1 - spikeProgress) + bladeTip.x * spikeProgress,
        y: tipLeft.y * (1 - spikeProgress) + bladeTip.y * spikeProgress,
      };
      const p3 = {
        x: tipRight.x * (1 - spikeProgress) + bladeTip.x * spikeProgress,
        y: tipRight.y * (1 - spikeProgress) + bladeTip.y * spikeProgress,
      };

      if (first) {
        shapeCtx.moveTo(p1.x, p1.y);
        first = false;
      }

      shapeCtx.lineTo(p2.x, p2.y);
      shapeCtx.lineTo(p3.x, p3.y);
      shapeCtx.lineTo(p4.x, p4.y);
    }
  }


    shapeCtx.closePath();
    shapeCtx.strokeStyle = "#333";
    shapeCtx.lineWidth = 2;
    shapeCtx.stroke();
  }


shapeSlider.addEventListener('input', () => {
  console.log(shapeSlider.value);
  drawShape(Number(shapeSlider.value));
  
});
drawShape(0);

  </script>
</body>
</html>