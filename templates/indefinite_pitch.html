<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Questionnaire UI</title>

  <style>
    body {
      margin: 0;
      font-family: Helvetica, sans-serif;
      background-color: #f4f4f4;
    }

    .questionnaire__container {
      position: relative;
      width: 100%;
      min-width: 685px;
      min-height: 600px;
      padding: 40px;
      box-sizing: border-box;
      /* background-color: #ffffff; */
      box-shadow: 0 0 5px rgba(0,0,0,0.2);
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .questionnaire__main-content {
      display: flex;
      flex-direction: column;
      justify-content: space-around;
      align-items: center;
      min-height: 500px;
    }

    .questionnaire__title {
      text-align: center;
      width: 770px;
    }

    button.questionnaire__audio-play-button {
      width: 90px;
      height: 100px;
      background: #ffffff;
      border: 1px solid #000;
      font-size: 12px;
      cursor: pointer;
      box-shadow: 3px 3px 4px rgba(61, 69, 116, 0.4);
    }

    button.questionnaire__loop-toggle {
      width: 90px;
      padding: 10px 15px;
      font-size: 12px;
      border: 1px solid #000;
      background: #ffffff;
      cursor: pointer;
      box-shadow: 3px 3px 4px rgba(61, 69, 116, 0.4);
    }

    .loop-toggle-wrapper {
      display: flex;
      align-items: center;
      gap: 8px; /* space between arrow and button */
    }

    .loop-arrow {
      font-size: 16px;
      color: #3D4574;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
    }




    .questionnaire__sinewave-slider {
      width: 1250px;
    }

    button.questionnaire__no-match-button {
      width: 214px;
      height: 100px;
      background: #ffffff;
      border: 1px solid #000;
      font-size: 12px;
      cursor: pointer;
      box-shadow: 3px 3px 4px rgba(61, 69, 116, 0.4);
    }

    .questionnaire__no-match-button.active {
      background-color: #ff4d4d; /* red */
      color: white;
      border-color: #aa0000;
    }


    button.questionnaire__submit-button {
      width: 350px;
      height: 100px;
      background: #ffffff;
      border: 1px solid #000;
      font-size: 12px;
      cursor: pointer;
      box-shadow: 3px 3px 4px rgba(61, 69, 116, 0.4);
    }

    .questionnaire__info-box {
      position: absolute;
      cursor: pointer;
      right: 40px;
      top: 40px;
      width: 60px;
      height: 60px;
      border: 1px solid #000;
      background: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
    }

    .slider-horizontal {
      position: absolute;
      left: 260px;
      top: 260px;
      width: 160px;
    }

    .slider-label {
      position: absolute;
      left: 336px;
      top: 240px;
      font-size: 12px;
      width: 180px;
      text-align: center;
    }

    .slider-vertical-wrapper {
      position: absolute;
      width: 30px;
      height: 100px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .slider-vertical {
      writing-mode: bt-lr; /* Bottom to top */
      transform: rotate(270deg);
      width: 100px;
    }

    #synth-slider {
      left: 365px;
      top: 340px;
    }

    #sound-slider {
      left: 425px;
      top: 340px;
    }

    /* Modal Styling */
    .modal {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: rgba(0, 0, 0, 0.6);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
    }

    .modal-content {
      
      width: 500px;
      background-color: white;
      padding: 30px 40px;
      border-radius: 8px;
      text-align: center;
      max-width: 600px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      position: absolute;
      top: 0;
    }

    .modal h2 {
      margin-top: 0;
    }

    .modal p {
      margin: 20px 0;
    }

    .start-btn {
      padding: 10px 20px;
      font-size: 14px;
      cursor: pointer;
      background-color: #3D4574;
      color: white;
      border: none;
      border-radius: 4px;
    }

    .start-btn:hover {
      background-color: #2c3455;
    }

    #sampleIcon {
      font-size: 20px;
    }

    .slider-locked {
      opacity: 0.5;
    }

    #infoBoxModal{
      display: none;
    }

    @keyframes pulseGreen {
      0%   { background-color: #a8f0a2; }
      50%  { background-color: #38c24f; }
      100% { background-color: #a8f0a2; }
    }

    .training-active {
      animation: pulseGreen 1.2s infinite;
      color: #000;
      font-weight: bold;
      border: 2px solid #38c24f;
    }

    #soundProgressBox.training-active {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: #d4f4d1;
      border: 2px solid #2f6b28;
      font-size: 20px;
      font-weight: bold;
      padding: 12px 24px;
      border-radius: 8px;
      z-index: 999;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      transition: all 0.3s ease;
    }

   
    .sound-progress-box {
      border: 1px solid #000;
      position: absolute;
      top: 40px;
      left: 40px;
      background: #fff;
      padding: 8px 14px;
      font-size: 14px;
      z-index: 10;
      transition: all 0.3s ease;
    }

    .sound-progress-box.training-active {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: #d4f4d1;
      border: 2px solid #2f6b28;
      font-size: 20px;
      font-weight: bold;
      padding: 12px 24px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }


  </style>
</head>
<body>

<div class="modal" id="infoBoxModal">
  <div class="modal-content">
    <h2>Î Î»Î·ÏÎ¿Ï†Î¿ÏÎ¯ÎµÏ‚ Î³Î¹Î± Ï„Î¿ Î ÎµÎ¯ÏÎ±Î¼Î±</h2>
    <p style="text-align: left; line-height: 1.6;">
      Î“Î¹Î± Î½Î± Î±ÎºÎ¿ÏÏƒÎµÏ„Îµ Ï„Î¿Î½ Î®Ï‡Î¿ Ï€Î±Ï„Î®ÏƒÏ„Îµ Ï„Î¿ <strong>ÎºÎµÎ½Ï„ÏÎ¹ÎºÏŒ ÎºÎ¿Ï…Î¼Ï€Î¯</strong> (Î® Ï„Î¿ <strong>Ï€Î»Î®ÎºÏ„ÏÎ¿ A</strong> ÏƒÏ„Î¿ Ï€Î»Î·ÎºÏ„ÏÎ¿Î»ÏŒÎ³Î¹Î¿), ÎµÎ½Ï Î³Î¹Î± Î½Î± Î±ÎºÎ¿ÏÏƒÎµÏ„Îµ Ï„Î¿ Î·Î¼Î¯Ï„Î¿Î½Î¿ <strong>Ï€Î±Ï„Î®ÏƒÏ„Îµ (click) Ï€Î¬Î½Ï‰ ÏƒÏ„Î¿ slider</strong>.<br>
      Î”ÎµÎ½ Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½ ÏƒÏ‰ÏƒÏ„Î­Ï‚ Î® Î»Î¬Î¸Î¿Ï‚ Î±Ï€Î±Î½Ï„Î®ÏƒÎµÎ¹Ï‚ â€“ Î¼Î±Ï‚ ÎµÎ½Î´Î¹Î±Ï†Î­ÏÎµÎ¹ Î½Î± ÎºÎ±Ï„Î±Î³ÏÎ¬ÏˆÎ¿Ï…Î¼Îµ Ï„Î· Î´Î¹ÎºÎ® ÏƒÎ±Ï‚ <strong>Ï…Ï€Î¿ÎºÎµÎ¹Î¼Î­Î½Î¹ÎºÎ® Î±Î½Ï„Î¯Î»Î·ÏˆÎ· Î³Î¹Î± Ï„Î¿ Ï„Î¿Î½Î¹ÎºÏŒ ÏÏˆÎ¿Ï‚</strong>.<br>
    </p>
  </div>
</div> 

<div class="modal" id="consentModal" style="overflow-y: auto;">
  <div class="modal-content">
    <h2>Î Î»Î·ÏÎ¿Ï†Î¿ÏÎ¯ÎµÏ‚ Î³Î¹Î± Ï„Î¿ Î ÎµÎ¯ÏÎ±Î¼Î±</h2>
    <p style="text-align: left; line-height: 1.6;">
      Î£Î±Ï‚ ÎµÏ…Ï‡Î±ÏÎ¹ÏƒÏ„Î¿ÏÎ¼Îµ Î³Î¹Î± Ï„Î· ÏƒÏ…Î¼Î¼ÎµÏ„Î¿Ï‡Î® ÏƒÎ±Ï‚ ÏƒÏ„Î¿ Ï€ÎµÎ¯ÏÎ±Î¼Î±!<br><br>
      ÎœÎ­ÏƒÏ‰ Î±Ï…Ï„Î¿Ï Ï„Î¿Ï… Ï€ÎµÎ¹ÏÎ¬Î¼Î±Ï„Î¿Ï‚ Î¸Î­Î»Î¿Ï…Î¼Îµ Î½Î± Î¼ÎµÎ»ÎµÏ„Î®ÏƒÎ¿Ï…Î¼Îµ Ï„Î·Î½ <strong>Î±Î½Ï„Î¯Î»Î·ÏˆÎ· Ï„Î¿Ï… Ï„Î¿Î½Î¹ÎºÎ¿Ï ÏÏˆÎ¿Ï…Ï‚ Ï„Î¿Î½Î¹ÎºÎ¬ Î±ÎºÎ±Î¸ÏŒÏÎ¹ÏƒÏ„Ï‰Î½ Î®Ï‡Ï‰Î½ - Î¸Î¿ÏÏÎ²Ï‰Î½</strong>.<br>
      Î˜Î± Î±ÎºÎ¿ÏÏƒÎµÏ„Îµ Î¼Î¹Î± ÏƒÎµÎ¹ÏÎ¬ Î±Ï€ÏŒ Î®Ï‡Î¿Ï…Ï‚. Î“Î¹Î± ÎºÎ¬Î¸Îµ Î®Ï‡Î¿, Î¸Î± Ï‡ÏÎµÎ¹Î±ÏƒÏ„ÎµÎ¯ Î½Î± Î±Î½Ï„Î¹ÏƒÏ„Î¿Î¹Ï‡Î¯ÏƒÎµÏ„Îµ Ï„Î¿ Ï„Î¿Î½Î¹ÎºÏŒ Ï„Î¿Ï… ÏÏˆÎ¿Ï‚ (pitch) Î¼Îµ ÎµÎºÎµÎ¯Î½Î¿ ÎµÎ½ÏŒÏ‚ Î·Î¼Î¯Ï„oÎ½Î¿Ï… (sinewave) Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÏÎ½Ï„Î±Ï‚ Ï„Î¿ slider ÏƒÏ„Î·Î½ Î¿Î¸ÏŒÎ½Î·.<br><br>

      Î“Î¹Î± Î½Î± Î±ÎºÎ¿ÏÏƒÎµÏ„Îµ Ï„Î¿Î½ Î®Ï‡Î¿ Ï€Î±Ï„Î®ÏƒÏ„Îµ Ï„Î¿ <strong>ÎºÎµÎ½Ï„ÏÎ¹ÎºÏŒ ÎºÎ¿Ï…Î¼Ï€Î¯</strong> (Î® <strong>Ï„Î¿ Ï€Î»Î®ÎºÏ„ÏÎ¿ A</strong> ÏƒÏ„Î¿ Ï€Î»Î·ÎºÏ„ÏÎ¿Î»ÏŒÎ³Î¹Î¿), ÎµÎ½Ï Î³Î¹Î± Î½Î± Î±ÎºÎ¿ÏÏƒÎµÏ„Îµ Ï„Î¿ Î·Î¼Î¯Ï„Î¿Î½Î¿ <strong>Ï€Î±Ï„Î®ÏƒÏ„Îµ (click) Ï€Î¬Î½Ï‰ ÏƒÏ„Î¿ slider</strong>.<br>
      Î”ÎµÎ½ Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½ ÏƒÏ‰ÏƒÏ„Î­Ï‚ Î® Î»Î¬Î¸Î¿Ï‚ Î±Ï€Î±Î½Ï„Î®ÏƒÎµÎ¹Ï‚ â€“ Î¼Î±Ï‚ ÎµÎ½Î´Î¹Î±Ï†Î­ÏÎµÎ¹ Î½Î± ÎºÎ±Ï„Î±Î³ÏÎ¬ÏˆÎ¿Ï…Î¼Îµ Ï„Î· Î´Î¹ÎºÎ® ÏƒÎ±Ï‚ <strong>Ï…Ï€Î¿ÎºÎµÎ¹Î¼Î­Î½Î¹ÎºÎ® Î±Î½Ï„Î¯Î»Î·ÏˆÎ· Î³Î¹Î± Ï„Î¿ Ï„Î¿Î½Î¹ÎºÏŒ ÏÏˆÎ¿Ï‚</strong>.<br><br>

      Î— ÏƒÏ…Î¼Î¼ÎµÏ„Î¿Ï‡Î® ÏƒÎ±Ï‚ ÏƒÏ„Î¿ Ï€ÎµÎ¯ÏÎ±Î¼Î± ÎµÎ¯Î½Î±Î¹ <strong>ÎµÎ¸ÎµÎ»Î¿Î½Ï„Î¹ÎºÎ®</strong> ÎºÎ±Î¹ ÎµÎ¯ÏƒÏ„Îµ ÎµÎ»ÎµÏÎ¸ÎµÏÎ¿Î¹ Î½Î± Î±Ï€Î¿Ï‡Ï‰ÏÎ®ÏƒÎµÏ„Îµ Î±Î½Î¬ Ï€Î¬ÏƒÎ± ÏƒÏ„Î¹Î³Î¼Î® Ï‡Ï‰ÏÎ¯Ï‚ Ï€ÎµÏÎ±Î¹Ï„Î­ÏÏ‰ ÏƒÏ…Î½Î­Ï€ÎµÎ¹ÎµÏ‚.
      Î¤Î¿ Ï€ÎµÎ¯ÏÎ±Î¼Î± Î­Ï‡ÎµÎ¹ Î»Î¬Î²ÎµÎ¹ Î¬Î´ÎµÎ¹Î± Î±Ï€ÏŒ Ï„Î·Î½ <strong>Î•Ï€Î¹Ï„ÏÎ¿Ï€Î® Î—Î¸Î¹ÎºÎ®Ï‚ ÎºÎ±Î¹ Î”ÎµÎ¿Î½Ï„Î¿Î»Î¿Î³Î¯Î±Ï‚ Ï„Î·Ï‚ ÎˆÏÎµÏ…Î½Î±Ï‚ Ï„Î¿Ï… Î‘Î Î˜</strong>.<br><br>

      Î£Î±Ï‚ ÎµÏ…Ï‡Î±ÏÎ¹ÏƒÏ„Î¿ÏÎ¼Îµ ÎºÎ±Î¹ Ï€Î¬Î»Î¹ Î³Î¹Î± Ï„Î· ÏƒÏ…Î½ÎµÏÎ³Î±ÏƒÎ¯Î± ÏƒÎ±Ï‚!!
    </p>

    <button class="start-btn" id="play-reference-btn" >â–¶ Î¤ÏŒÎ½Î¿Ï‚ Î‘Î½Î±Ï†Î¿ÏÎ¬Ï‚ 1 kHz</button>
    <p style="font-size: 13px; color: #444;">(Î”Î¹Î¬ÏÎºÎµÎ¹Î± ~2 Î´ÎµÏ…Ï„., Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÏ„Îµ Ï„Î¿Î½ Î³Î¹Î± ÏÏÎ¸Î¼Î¹ÏƒÎ· Î­Î½Ï„Î±ÏƒÎ·Ï‚)</p>

    <hr style="margin: 20px 0;">
    <button class="start-btn" id="consent-continue-btn">Î£Ï…Î½ÎµÏ‡Î¯ÏƒÏ„Îµ</button>
  </div>
</div>  
<script>
// Reference Tone Button
const refBtn = document.getElementById("play-reference-btn");

refBtn.addEventListener("click", () => {
  initAudioContext();

  // Stop if already playing
  if (osc) {
    stopSinewave();
    return;
  }

  // Create 1 kHz reference tone, short duration
  const refOsc = audioContext.createOscillator();
  const refGain = audioContext.createGain();
  refOsc.frequency.value = 1000; // Hz
  refOsc.type = "sine";
  refGain.gain.value = 0.2; // moderate loudness

  refOsc.connect(refGain).connect(audioContext.destination);
  refOsc.start();
  refOsc.stop(audioContext.currentTime + 2.0); // 2 seconds

  // Simple visual feedback (button flash)
  refBtn.textContent = "â¹ Î Î±ÏÏƒÎ·";
  refBtn.disabled = true;
  refBtn.style.backgroundColor = "#d1e7d3";

  refOsc.onended = () => {
    refBtn.textContent = "â–¶ Î¤ÏŒÎ½Î¿Ï‚ Î‘Î½Î±Ï†Î¿ÏÎ¬Ï‚ 1 kHz";
    refBtn.disabled = false;
    refBtn.style.backgroundColor = "";
  };
});
</script>
<div class="modal" id="introModal" style="display: none; overflow-y: auto;">
  <div class="modal-content">
    <h2>ÎšÎ±Î»ÏÏ‚ Î®ÏÎ¸Î±Ï„Îµ</h2>
    <p>
      Î Î±ÏÎ±ÎºÎ±Î»Î¿ÏÎ¼Îµ ÏƒÏ…Î¼Ï€Î»Î·ÏÏÏƒÏ„Îµ Ï„Î± Ï€Î±ÏÎ±ÎºÎ¬Ï„Ï‰ ÏƒÏ„Î¿Î¹Ï‡ÎµÎ¯Î± Ï€ÏÎ¹Î½ Î¾ÎµÎºÎ¹Î½Î®ÏƒÎµÏ„Îµ:
    </p>
    <form id="userInfoForm" style="text-align: left; font-size: 16px;">
      <label for="gender">Î¦ÏÎ»Î¿:</label><br>
      <!-- <input type="text" id="gender" name="gender" required><br><br> -->
      <select id="gender" name="gender" required>
        <option value="" disabled selected>Î•Ï€Î¹Î»Î­Î¾Ï„Îµ...</option>
        <option>Î†ÏÏÎµÎ½</option>
        <option>Î˜Î®Î»Ï…</option>
        <option>Î†Î»Î»Î¿</option>
        <option>Î”ÎµÎ½ Î±Ï€Î±Î½Ï„Ï</option>
      </select><br><br>

      <label for="age">Î—Î»Î¹ÎºÎ¯Î±:</label><br>
      <input type="number" id="age" name="age" min="5" max="120" required><br><br>

      <label for="hearing">ÎˆÏ‡ÎµÏ„Îµ Î´Î¹Î±Î³Î½Ï‰ÏƒÎ¼Î­Î½Î± Ï€ÏÎ¿Î²Î»Î®Î¼Î±Ï„Î± Î±ÎºÎ¿Î®Ï‚;</label><br>
      <select id="hearing" name="hearing" required>
        <option value="" disabled selected>Î•Ï€Î¹Î»Î­Î¾Ï„Îµ...</option>
        <option>ÎŒÏ‡Î¹</option>
        <option>Î•Î»Î±Ï†ÏÎ¹Î¬ Î±Ï€ÏÎ»ÎµÎ¹Î±</option>
        <option>ÎœÎ­Ï„ÏÎ¹Î± Î±Ï€ÏÎ»ÎµÎ¹Î±</option>
        <option>Î£Î¿Î²Î±ÏÎ® Î±Ï€ÏÎ»ÎµÎ¹Î±</option>
        <option>Î†Î»Î»Î¿</option>
      </select><br><br>

      <label>Î”Î¹Î±Î¸Î­Ï„ÎµÏ„Îµ Î±Ï€ÏŒÎ»Ï…Ï„Î¿ Î±Ï…Ï„Î¯ (absolute pitch);</label><br>
      <input type="radio" name="absolutePitch" value="yes" required> ÎÎ±Î¹<br>
      <input type="radio" name="absolutePitch" value="no"> ÎŒÏ‡Î¹<br><br>

      <label for="experience">Î•Ï€Î¯Ï€ÎµÎ´Î¿ ÎµÎ¼Ï€ÎµÎ¹ÏÎ¯Î±Ï‚ Î¼Îµ Ï„Î· Î¼Î¿Ï…ÏƒÎ¹ÎºÎ®:</label><br>
      <select id="experience" name="experience" required>
        <option value="" disabled selected>Î•Ï€Î¹Î»Î­Î¾Ï„Îµ...</option>
        <option>Î•Ï€Î±Î³Î³ÎµÎ»Î¼Î±Ï„Î¯Î±Ï‚ Î¼Î¿Ï…ÏƒÎ¹ÎºÏŒÏ‚ (ÏƒÏ€Î¿Ï…Î´Î­Ï‚, Î´Î¹Î´Î±ÏƒÎºÎ±Î»Î¯Î± Î® ÏƒÏ…Ï‡Î½Î­Ï‚ ÎµÎ¼Ï†Î±Î½Î¯ÏƒÎµÎ¹Ï‚)</option>
        <option>Î—Î¼Î¹-ÎµÏ€Î±Î³Î³ÎµÎ»Î¼Î±Ï„Î¯Î±Ï‚ (Î¼ÎµÏÎ¹ÎºÎ® Î±Ï€Î±ÏƒÏ‡ÏŒÎ»Î·ÏƒÎ·, Î·Ï‡Î¿Î³ÏÎ±Ï†Î®ÏƒÎµÎ¹Ï‚ Î® ÏƒÏ€Î¿Ï…Î´Î­Ï‚ ÏƒÎµ ÎµÎ¾Î­Î»Î¹Î¾Î·)</option>
        <option>Î•ÏÎ±ÏƒÎ¹Ï„Î­Ï‡Î½Î·Ï‚ (Î¼Î±Î¸Î®Î¼Î±Ï„Î±, ÏƒÏ…Î¼Î¼ÎµÏ„Î¿Ï‡Î® ÏƒÎµ ÏƒÏ…Î³ÎºÏÎ¿Ï„Î®Î¼Î±Ï„Î± Î® Ï‡Î¿ÏÏ‰Î´Î¯Î±)</option>
        <option>Î‘Ï€Î»ÏŒÏ‚ Î±ÎºÏÎ¿Î±Ï„Î®Ï‚ / Ï†Î¯Î»Î¿Ï‚ Ï„Î·Ï‚ Î¼Î¿Ï…ÏƒÎ¹ÎºÎ®Ï‚</option>
        <option>ÎšÎ±Î¼Î¯Î± Î¹Î´Î¹Î±Î¯Ï„ÎµÏÎ· ÎµÎ¼Ï€ÎµÎ¹ÏÎ¯Î±</option>
      </select><br><br>

      <label for="yearsExperience">ÎˆÏ„Î· ÎµÎ½ÎµÏÎ³Î®Ï‚ ÎµÎ½Î±ÏƒÏ‡ÏŒÎ»Î·ÏƒÎ·Ï‚ Î¼Îµ Ï„Î· Î¼Î¿Ï…ÏƒÎ¹ÎºÎ®:</label><br>
      <input type="number" id="yearsExperience" name="yearsExperience" min="0" max="80" step="1" required><br><br>

      <label for="trainingType">ÎœÎµ Ï€Î¿Î¹Î¿ ÎµÎ¯Î´Î¿Ï‚ Î¼Î¿Ï…ÏƒÎ¹ÎºÎ®Ï‚ ÎµÎºÏ€Î±Î¯Î´ÎµÏ…ÏƒÎ·Ï‚ ÎµÎ¯ÏƒÏ„Îµ Ï€ÎµÏÎ¹ÏƒÏƒÏŒÏ„ÎµÏÎ¿ ÎµÎ¾Î¿Î¹ÎºÎµÎ¹Ï‰Î¼Î­Î½Î¿Î¹:</label><br>
      <select id="trainingType" name="trainingType" required>
        <option value="" disabled selected>Î•Ï€Î¹Î»Î­Î¾Ï„Îµ...</option>
        <option>Î•ÎºÏ„ÎµÎ»ÎµÏƒÏ„Î¹ÎºÎ® (ÏŒÏÎ³Î±Î½Î¿, Ï†Ï‰Î½Î®)</option>
        <option>Î˜ÎµÏ‰ÏÎ·Ï„Î¹ÎºÎ® / Î£ÏÎ½Î¸ÎµÏƒÎ·</option>
        <option>Î‘ÎºÎ¿Ï…ÏƒÏ„Î¹ÎºÎ® / Î¤ÎµÏ‡Î½Î¿Î»Î¿Î³Î¹ÎºÎ®</option>
        <option>ÎšÎ±Î¼Î¯Î±</option>
      </select><br><br>

      <label>Î‘ÏƒÏ‡Î¿Î»ÎµÎ¯ÏƒÏ„Îµ ÎµÎºÏ„ÎµÎ»ÎµÏƒÏ„Î¹ÎºÎ¬ Î¼Îµ ÎºÎ¬Ï€Î¿Î¹Î¿ Î¼Î¿Ï…ÏƒÎ¹ÎºÏŒ/Î± ÏŒÏÎ³Î±Î½Î¿/Î± (Ï€.Ï‡. Ï€Î¹Î¬Î½Î¿, Ï†Ï‰Î½Î®);</label><br>
      <input type="radio" name="instrument" value="yes" required> ÎÎ±Î¹<br>
      <input type="radio" name="instrument" value="no"> ÎŒÏ‡Î¹<br><br>

      <div id="instrumentNameField" style="display: none;">
        <label for="instrumentName">Î‘Î½ Î½Î±Î¹, Ï€Î¿Î¹Î¿/Î±;</label><br>
        <input type="text" id="instrumentName" name="instrumentName"><br><br>
      </div>

      <!--<label for="equipment">Î¤Î¹ Î±ÎºÎ¿Ï…ÏƒÏ„Î¹ÎºÏŒ ÎµÎ¾Î¿Ï€Î»Î¹ÏƒÎ¼ÏŒ Î¸Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ Î³Î¹Î± Ï„Î¿ Ï€ÎµÎ¯ÏÎ±Î¼Î±;</label><br>
      <select id="equipment" name="equipment" required>
        <option value="" disabled selected>Î•Ï€Î¹Î»Î­Î¾Ï„Îµ...</option>
        <option>ÎšÎ»ÎµÎ¹ÏƒÏ„Î¿Ï Î¤ÏÏ€Î¿Ï… (Over - Ear)</option>
        <option>Î‘ÎºÎ¿Ï…ÏƒÏ„Î¹ÎºÎ¬ ÏˆÎµÎ¯ÏÎµÏ‚ (In - Ear)</option>
        <option>Î•Ï€Î¯ Ï„Î¿Ï… Î‘Ï…Ï„Î¹Î¿Ï (On - Ear)</option>
        <option>Monitors</option>
      </select><br><br>-->

      <label>ÎÎ­ÏÎµÏ„Îµ Ï„Î¹ ÎµÎ¯Î½Î±Î¹ Ï„Î¿ Î¤Î¿Î½Î¹ÎºÏŒ ÎÏˆÎ¿Ï‚;</label><br>
      <input type="radio" name="knowPitch" value="yes" required> ÎÎ±Î¹<br>
      <input type="radio" name="knowPitch" value="no"> ÎŒÏ‡Î¹<br><br>

      <div id="pitchExplanation" style="display: none; margin-top: 20px;">
        <strong>Î¤Î¹ ÎµÎ¯Î½Î±Î¹ Ï„Î¿ Î¤Î¿Î½Î¹ÎºÏŒ ÎÏˆÎ¿Ï‚:</strong><br>
        Î¦Î±Î½Ï„Î±ÏƒÏ„ÎµÎ¯Ï„Îµ ÏŒÏ„Î¹ Î±ÎºÎ¿ÏÏ„Îµ Î´Î¹Î¬Ï†Î¿ÏÎµÏ‚ Ï†Ï‰Î½Î­Ï‚. ÎˆÎ½Î± ÏƒÏ†ÏÏÎ¹Î³Î¼Î± Î® Î¼Î¹Î± Ï€Î±Î¹Î´Î¹ÎºÎ® Ï†Ï‰Î½Î® Î±ÎºÎ¿ÏÎ³Î¿Î½Ï„Î±Î¹ ÏˆÎ·Î»Î¬, ÎµÎ½Ï Î­Î½Î± Î¼Ï€Î¿Ï…Î¼Ï€Î¿Ï…Î½Î·Ï„ÏŒ Î® Î­Î½Î±Ï‚ Î²ÏÏ…Ï‡Î·Î¸Î¼ÏŒÏ‚ Î±ÎºÎ¿ÏÎ³Î¿Î½Ï„Î±Î¹ Ï‡Î±Î¼Î·Î»Î¬.<br>
        Î£Ï„Î¿ Ï€Î¹Î¬Î½Î¿, Î¿Î¹ Î½ÏŒÏ„ÎµÏ‚ Î´ÎµÎ¾Î¹Î¬ ÎµÎ¯Î½Î±Î¹ Ï€Î¹Î¿ ÏˆÎ·Î»Î­Ï‚ ÎºÎ±Î¹ Î¿Î¹ Î½ÏŒÏ„ÎµÏ‚ Î±ÏÎ¹ÏƒÏ„ÎµÏÎ¬ Ï€Î¹Î¿ Ï‡Î±Î¼Î·Î»Î­Ï‚.<br>
        <em>Î‘Ï…Ï„Î® Î· Î±Î¯ÏƒÎ¸Î·ÏƒÎ· Ï„Î¿Ï… Ï€ÏŒÏƒÎ¿ ÏˆÎ·Î»ÏŒÏ‚ Î® Ï€ÏŒÏƒÎ¿ Ï‡Î±Î¼Î·Î»ÏŒÏ‚ ÎµÎ¯Î½Î±Î¹ Î­Î½Î±Ï‚ Î®Ï‡Î¿Ï‚, Î±Ï…Ï„ÏŒ Î»Î­Î¼Îµ Ï„Î¿Î½Î¹ÎºÏŒ ÏÏˆÎ¿Ï‚.</em>
      </div><br>

      <strong> Î‘ÏÏ‡Î¹ÎºÎ¬ Î¸Î± Î±ÎºÎ¿ÏÏƒÎµÏ„Îµ Ï„ÏÎµÎ¹Ï‚ ÎµÎ½Î´ÎµÎ¹ÎºÏ„Î¹ÎºÎ¿ÏÏ‚ Î®Ï‡Î¿Ï…Ï‚ Î³Î¹Î± Î½Î± ÎµÎ¾Î¿Î¹ÎºÎµÎ¹Ï‰Î¸ÎµÎ¯Ï„Îµ Î¼Îµ Ï„Î¿ Ï€ÎµÎ¯ÏÎ±Î¼Î±.</strong><br><br>

      <!-- âœ… Required consent -->
      <div style="margin:16px 0; padding:10px; border:1px solid #ddd; border-radius:8px;">
        <p style="margin-top:0;">
          Î£Ï…Î¼Î¼ÎµÏ„Î¿Ï‡Î¹ÎºÎ® ÏƒÏ…Î½Î±Î¯Î½ÎµÏƒÎ·: Î£Ï…Î¼Ï†Ï‰Î½Ï ÏŒÏ„Î¹ Ï„Î± Î±Î½ÏÎ½Ï…Î¼Î± Î´ÎµÎ´Î¿Î¼Î­Î½Î± Î¼Î¿Ï… Î¼Ï€Î¿ÏÎ¿ÏÎ½ Î½Î±
          Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î·Î¸Î¿ÏÎ½ Î³Î¹Î± ÎµÏÎµÏ…Î½Î·Ï„Î¹ÎºÎ¿ÏÏ‚ ÏƒÎºÎ¿Ï€Î¿ÏÏ‚ ÏƒÏÎ¼Ï†Ï‰Î½Î± Î¼Îµ Ï„Î·Î½ Ï€ÎµÏÎ¹Î³ÏÎ±Ï†Î® Ï„Î¿Ï… Ï€ÎµÎ¹ÏÎ¬Î¼Î±Ï„Î¿Ï‚.
          ÎœÏ€Î¿ÏÏ Î½Î± Î±Ï€Î¿Ï‡Ï‰ÏÎ®ÏƒÏ‰ Î¿Ï€Î¿Î¹Î±Î´Î®Ï€Î¿Ï„Îµ ÏƒÏ„Î¹Î³Î¼Î® Ï‡Ï‰ÏÎ¯Ï‚ ÏƒÏ…Î½Î­Ï€ÎµÎ¹ÎµÏ‚.
        </p>
        <label style="display:flex; align-items:center; gap:8px;">
          <input type="checkbox" id="consentCheckbox" required>
          <span>ÎÎ±Î¹, ÏƒÏ…Î½Î±Î¹Î½Ï</span>
        </label>

        <!-- (Optional) show a link to full consent text / PDF -->
        <a href="/static/indefinite_pitch/Consent-details.pdf" target="_blank" rel="noopener">Î‘Î½Î±Î»Ï…Ï„Î¹ÎºÏŒ ÎºÎµÎ¯Î¼ÎµÎ½Î¿ ÏƒÏ…Î½Î±Î¯Î½ÎµÏƒÎ·Ï‚</a>

        <!-- Hidden consent version (so you can track which text they saw) -->
        <input type="hidden" id="consentVersion" value="v1.0-2025-10-07">
      </div>

      <div style="display: flex; justify-content: center; margin-top: 20px;">
        <button type="submit" class="start-btn" id="start-btn" disabled>ÎˆÎ½Î±ÏÎ¾Î·</button>
      </div>

    </form>
  </div>
</div>


<div class="modal" id="thankYouModal" style="display: none;">
  <div class="modal-content">
    <h2>Î£Î±Ï‚ ÎµÏ…Ï‡Î±ÏÎ¹ÏƒÏ„Î¿ÏÎ¼Îµ!</h2>
    <p>
      Î— ÏƒÏ…Î¼Î¼ÎµÏ„Î¿Ï‡Î® ÏƒÎ±Ï‚ ÏƒÏ„Î¿ ÎµÏÏ‰Ï„Î·Î¼Î±Ï„Î¿Î»ÏŒÎ³Î¹Î¿ Î¿Î»Î¿ÎºÎ»Î·ÏÏÎ¸Î·ÎºÎµ Î¼Îµ ÎµÏ€Î¹Ï„Ï…Ï‡Î¯Î±.<br>
      Î•ÎºÏ„Î¹Î¼Î¿ÏÎ¼Îµ Ï„Î¿Î½ Ï‡ÏÏŒÎ½Î¿ ÎºÎ±Î¹ Ï„Î· ÏƒÏ…Î¼Î²Î¿Î»Î® ÏƒÎ±Ï‚ ÏƒÏ„Î·Î½ Î­ÏÎµÏ…Î½Î±.
    </p>
    <!-- <button class="start-btn" onclick="location.reload()">Î•Ï€Î±Î½ÎµÎºÎºÎ¯Î½Î·ÏƒÎ·</button> -->
  </div>
</div>

<!-- Main Content -->
<div class="questionnaire__container" id="questionnaireContent">
    <h2 class="questionnaire__title">Î¤Î¿Ï€Î¿Î¸ÎµÏ„Î®ÏƒÏ„Îµ Ï„Î¿ slider ÏƒÏ„Î¿ ÏƒÎ·Î¼ÎµÎ¯Î¿ Ï€Î¿Ï… Ï€Î¹ÏƒÏ„ÎµÏÎµÏ„Îµ ÏŒÏ„Î¹ Ï„Î¿ Ï„Î¿Î½Î¹ÎºÏŒ ÏÏˆÎ¿Ï‚ (pitch) Î±Î½Ï„Î¹ÏƒÏ„Î¿Î¹Ï‡ÎµÎ¯ ÏƒÏ„Î¿ ÎµÎºÎ¬ÏƒÏ„Î¿Ï„Îµ Î·Ï‡Î·Ï„Î¹ÎºÏŒ Ï€Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î±</h2>
    <div class="questionnaire__info-box" id="questionnaire__info-box">i</div>
    <div class="questionnaire__main-content">
        <!-- Buttons -->
        <div style="display: flex; align-items: center; gap: 10px;">
          <button id="samplePlayBtn" class="questionnaire__audio-play-button">
            <span id="sampleIcon">â–¶</span><br>Î Î±Ï„Î®ÏƒÏ„Îµ "A" Î® ÎºÎ»Î¹ÎºÎ¬ÏÎµÏ„Îµ Î³Î¹Î± Î½Î± Ï€Î±Î¯Î¾ÎµÏ„Îµ Ï„Î¿Î½ Î®Ï‡Î¿
          </button>
          <div class="loop-toggle-wrapper">
            <div class="loop-arrow">â†</div>
            <button id="loopToggleBtn" class="questionnaire__loop-toggle">Loop: OFF</button>
          </div>
        </div>
        
        <div class="label">Î£Ï…Ï‡Î½ÏŒÏ„Î·Ï„Î± (Hz)</div>
        <input class="questionnaire__sinewave-slider" type="range" id="sineSlider" min="0" max="1000" step="1" disabled>

        <!-- ADD: Master volume control (relative to calibrated level) -->
        <div class="label" style="margin-top:12px;">ÎˆÎ½Ï„Î±ÏƒÎ· Ï„Î±Î»Î±Î½Ï„Ï‰Ï„Î® (sinewave)</div>
        <div class="volume-control" style="display:flex;align-items:center;gap:10px;">
          <input type="range" id="volumeSlider" min="-10" max="10" step="0.5" value="0" style="flex:1;">
          <span id="volumeReadout">0 dB</span>
        </div>

        <button class="questionnaire__no-match-button" id="no-match">Î”ÎµÎ½ Î²ÏÎ¯ÏƒÎºÏ‰ Î±Î½Ï„Î¹ÏƒÏ„Î¿Î¯Ï‡Î¹ÏƒÎ·</button>

        

        <button class="start-btn" id="next">Î•Ï€ÏŒÎ¼ÎµÎ½Î¿Ï‚ Î®Ï‡Î¿Ï‚</button>

    </div> 
    <div id="soundProgressBox" class="sound-progress-box">
      Î‰Ï‡Î¿Ï‚ 1 Î±Ï€ÏŒ 19
    </div>
    
</div>

<script>

const WARN_TEXT = "Î”ÎµÎ½ Î­Ï‡ÎµÏ„Îµ Î´Î¹Î±Î´ÏÎ¬ÏƒÎµÎ¹ Î¼Îµ Ï„Î¿ Ï€ÎµÏÎ¹Î²Î¬Î»Î»Î¿Î½ ÏƒÎµ Î±Ï…Ï„ÏŒÎ½ Ï„Î¿Î½ Î®Ï‡Î¿ â€” ÎµÎ¯ÏƒÏ„Îµ ÏƒÎ¯Î³Î¿Ï…ÏÎ¿Î¹ ÏŒÏ„Î¹ Î¸Î­Î»ÎµÏ„Îµ Î½Î± ÏƒÏ…Î½ÎµÏ‡Î¯ÏƒÎµÏ„Îµ;";

function generateSessionId() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    const r = Math.random() * 16 | 0,
          v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}


const sessionId = generateSessionId();

// experiment end flag
let experimentFinished = false;

let audioContext = null;
let osc = null;
let sineGain = null;
let isSinePlaying = false;

// ADD: master volume state and node
let masterGain = null;
let USER_VOL_DB = 0; // 0 dB = calibrated baseline

const sineSlider = document.getElementById("sineSlider");
const startBtn = document.getElementById("start-btn");
const consentModal = document.getElementById("consentModal");
const consentBtn = document.getElementById("consent-continue-btn");
const modal = document.getElementById("introModal");
const questionnaire = document.getElementById("questionnaireContent");
const questionnaireInfoBox = document.getElementById("questionnaire__info-box");
const infoBoxModal = document.getElementById("infoBoxModal");


/* ========= FULL INTERACTION LOGGING CORE ========= */

// Where to POST logs (youâ€™ll wire this in FastAPI later)
const LOG_ENDPOINT = "log_slider_events";

// Batch & cadence
const LOG_BUFFER_MAX = 25;      // flush when queue hits this
const LOG_FLUSH_MS  = 2000;     // or every 2s

let interactionQueue = [];
let currentQuestionId = 0;      // increments each Next
let logTimer = null;

function nowISO() { return new Date().toISOString(); }

function getCurrentContext() {
  return {
    session_id: sessionId,
    question_id: currentQuestionId,
    training: isTrainingPhase,
    sound: soundList?.[currentSoundIndex] || null,
    sound_index: currentSoundIndex,
  };
}

function enqueueEvent(eventType, payload = {}) {
  if (experimentFinished) return; // <- ignore logs after end
  const ctx = getCurrentContext();
  const rec = { t: nowISO(), event: eventType, ...ctx, ...payload };
  interactionQueue.push(rec);
  if (interactionQueue.length >= LOG_BUFFER_MAX) flushInteractions();
}

async function flushInteractions() {
  if (!interactionQueue.length) return;
  const batch = interactionQueue.slice();
  interactionQueue = [];
  try {
    await fetch(LOG_ENDPOINT, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ records: batch })
    });
  } catch (e) {
    // re-queue on failure
    interactionQueue = batch.concat(interactionQueue);
    console.warn("Log flush failed; will retry.", e);
  }
}

// periodic flush + on-hide/unload
if (!logTimer) logTimer = setInterval(flushInteractions, LOG_FLUSH_MS);
document.addEventListener("visibilitychange", () => {
  if (document.visibilityState === "hidden") flushInteractions();
});
window.addEventListener("beforeunload", () => { flushInteractions(); });

/* ========= PER-QUESTION STATS & TIMERS ========= */

let qStats = null;
let sampleStartTs = null;
let sineStartTs = null;
let concurrentStartTs = null;

function resetQuestionStats() {
  qStats = {
    // counts
    sample_play_presses: 0,   // button or 'A' key requests to play
    sample_stops: 0,
    sine_starts: 0,
    sine_stops: 0,
    loop_toggles: 0,
    loop_on_count: 0,
    no_match_clicks: 0,
    sine_interactions: 0,     // pitch slider input events
    vol_interactions: 0,      // volume slider input events

    // durations (ms)
    sample_total_ms: 0,
    sine_total_ms: 0,
    concurrent_total_ms: 0
  };

  sampleStartTs = null;
  sineStartTs = null;
  concurrentStartTs = null;
}

/* ========= GESTURE SAMPLING ========= */
const GESTURE_SAMPLE_MS = 250;  // sample both sliders @ 4 Hz
let gestureTimer = null;
let questionStartTs = null;

function currentGainContext(freqHz) {
  // useful in analysis; remove fields if you want smaller logs
  const eqGain = totalGainLinear(freqHz);
  const base   = BASE_GAIN_1KHZ * HEADROOM;
  const user   = Math.pow(10, (USER_VOL_DB || 0) / 20);
  const total  = base * eqGain * user;
  return { eq_gain_linear: eqGain, base_gain: base, user_gain_linear: user, total_gain_linear: total };
}

function startGestureCapture() {
  if (experimentFinished) return; // don't start if finished
  questionStartTs = performance.now();
  if (gestureTimer) clearInterval(gestureTimer);
  gestureTimer = setInterval(sampleGestureTick, GESTURE_SAMPLE_MS);
}

function stopGestureCapture() {
  if (gestureTimer) {
    clearInterval(gestureTimer);
    gestureTimer = null;
  }
}

function sampleGestureTick() {
  if (experimentFinished) return; // don't start if finished
  if (!sineSlider) return;
  const raw = parseFloat(sineSlider.value);
  const hz  = sliderToFrequency(raw);
  const volDb = (typeof USER_VOL_DB === "number") ? USER_VOL_DB
               : (document.getElementById("volumeSlider")
                  ? parseFloat(document.getElementById("volumeSlider").value)
                  : 0);
  const tRelMs = questionStartTs ? Math.round(performance.now() - questionStartTs) : null;

  const gctx = currentGainContext(hz);

  enqueueEvent("gesture_sample", {
    t_rel_ms: tRelMs,
    sine_raw: raw,
    sine_hz: hz,
    vol_db: volDb,
    is_sine_playing: !!isSinePlaying,
    is_sample_playing: !!isSamplePlaying,
    ...gctx
  });
}

/* ========= CONCURRENT PLAYBACK TRACKING ========= */
function maybeStartConcurrent() {
  if (isSamplePlaying && isSinePlaying && concurrentStartTs === null) {
    concurrentStartTs = performance.now();
    enqueueEvent("concurrent_begin", {});
  }
}
function maybeEndConcurrent(reason) {
  if (concurrentStartTs !== null && !(isSamplePlaying && isSinePlaying)) {
    const dt = Math.round(performance.now() - concurrentStartTs);
    qStats.concurrent_total_ms += dt;
    enqueueEvent("concurrent_end", { duration_ms: dt, reason });
    concurrentStartTs = null;
  }
}

function initAudioContext() {
  if (!audioContext) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
  } else if (audioContext.state === 'suspended') {
    audioContext.resume();
  }
}

// ADD: create master gain after compressor
function ensureMasterGain(ctx) {
  if (masterGain) return masterGain;
  masterGain = ctx.createGain();
  masterGain.gain.value = 1.0; // 0 dB
  return masterGain;
}

// ADD: dB <-> linear + smooth apply for user master volume
function dbToLinear(db) { return Math.pow(10, db / 20); }

function applyUserVolume(db) {
  USER_VOL_DB = db;
  if (masterGain) {
    setParamSmooth(masterGain.gain, dbToLinear(USER_VOL_DB), 0.03);
  }
  const ro = document.getElementById("volumeReadout");
  if (ro) ro.textContent = `${db.toFixed(1)} dB`;
}

function resetVolumeToCalibrated() {
  USER_VOL_DB = 0;
  const vs = document.getElementById("volumeSlider");
  if (vs) vs.value = "0";
  applyUserVolume(0);
}

/* ---------------- Equal-loudness (ISO 226 ~60 phon) ----------------
   SPL values â‰ˆ dB required at each frequency to match 60 dB at 1 kHz.
   Interpolate in log-frequency and dB, then convert Î”dB -> linear gain.
   You can swap this table with your exact ISO 226 tabulation if needed.
-------------------------------------------------------------------- */
const iso60phon = [
  { f: 20,   spl: 108 },
  { f: 25,   spl: 100 },
  { f: 31.5, spl: 94  },
  { f: 40,   spl: 88  },
  { f: 50,   spl: 84  },
  { f: 63,   spl: 80  },
  { f: 80,   spl: 76  },
  { f: 100,  spl: 73  },
  { f: 125,  spl: 70  },
  { f: 160,  spl: 67  },
  { f: 200,  spl: 65  },
  { f: 250,  spl: 63  },
  { f: 315,  spl: 61.5 },
  { f: 400,  spl: 60.5 },
  { f: 500,  spl: 60  },
  { f: 630,  spl: 59.5 },
  { f: 800,  spl: 59  },
  { f: 1000, spl: 60  }, // reference
  { f: 1250, spl: 60  },
  { f: 1600, spl: 60  },
  { f: 2000, spl: 60.5 },
  { f: 2500, spl: 61  },
  { f: 3150, spl: 60.5 },
  { f: 4000, spl: 58.5 },
  { f: 5000, spl: 57.5 },
  { f: 6300, spl: 58.5 },
  { f: 8000, spl: 61.5 },
  { f: 10000, spl: 66  },
  { f: 12500, spl: 74  },
  { f: 16000, spl: 86  }
];

// Log-frequency, dB-domain interpolation
function interpSPL(freq, table) {
  const f = Math.max(table[0].f, Math.min(table[table.length - 1].f, freq));
  for (let i = 0; i < table.length - 1; i++) {
    const p1 = table[i], p2 = table[i + 1];
    if (f >= p1.f && f <= p2.f) {
      const t = (Math.log10(f) - Math.log10(p1.f)) /
                (Math.log10(p2.f) - Math.log10(p1.f));
      return p1.spl + t * (p2.spl - p1.spl);
    }
  }
  return table[table.length - 1].spl;
}

// Reference is 1 kHz on the same phon curve
const REF_SPL_1KHZ = interpSPL(1000, iso60phon); // â‰ˆ 60 dB

// Convert required SPL difference to linear voltage gain
function equalLoudnessGain(freqHz) {
  const spl_f = interpSPL(freqHz, iso60phon);
  const delta_dB = spl_f - REF_SPL_1KHZ;      // how many dB more than 1 kHz
  return Math.pow(10, (-delta_dB) / 20);      // more required SPL -> higher linear gain
}

/* ---------------- Headphone compensation (Presonus HD7) ------------
   Provisional low-shelf style correction (positive = boost in dB).
   Replace with a measured FR-derived curve when available.
-------------------------------------------------------------------- */
// Presonus HD7 correction, LF bumped to close a ~5 dB deficit you measured
const headphoneCorr = [
  { f: 20,   spl: +24.0 }, // +5 over previous
  { f: 25,   spl: +23.5 },
  { f: 31.5, spl: +22.0 },
  { f: 40,   spl: +21.0 },
  { f: 50,   spl: +20.0 },
  { f: 63,   spl: +19.0 },
  { f: 80,   spl:  +18.0 },
  { f: 100,  spl:  +17.0 }, // was +3 â†’ now +8 (~+5 bump)
  { f: 125,  spl:  +15.0 }, // add ~+4
  { f: 160,  spl:  +12.5 }, // add ~+3
  { f: 200,  spl:  +11.0 }, // add ~+2
  { f: 250,  spl:  +9.0 }, // gentle taper
  { f: 315,  spl:  +7.0 },
  { f: 400,  spl:  +4.0 },
  { f: 500,  spl:  +2.0 },
  { f: 630,  spl:  0.0 },
  { f: 800,  spl:  0.0 },
  { f: 1000, spl:  0.0 },
  { f: 1250, spl:  0.0 },
  { f: 1600, spl:  0.0 },
  { f: 2000, spl:  0.0 },
  { f: 2500, spl:  0.0 },
  { f: 3150, spl:  0.0 },
  { f: 4000, spl:  0.0 },
  { f: 5000, spl:  0.0 },
  { f: 6300, spl:  0.0 },
  { f: 8000, spl:  0.0 },
  { f: 10000, spl: 0.0 },
  { f: 12500, spl: 0.0 },
  { f: 16000, spl: 0.0 }
];

function headphoneEQdB(freqHz) {
  return interpSPL(freqHz, headphoneCorr); // dB to add for the HD7
}

// Total linear gain = ISO equal-loudness (vs 1 kHz, negated) + headphone EQ
function totalGainLinear(freqHz) {
  const spl_f = interpSPL(freqHz, iso60phon);
  const deltaISO = spl_f - REF_SPL_1KHZ;   // dB more than 1 kHz needed
  const hp_dB = headphoneEQdB(freqHz);     // headphone compensation dB
  const total_dB = -deltaISO + hp_dB;      // apply ISO as gain (negate), then add HP EQ
  return Math.pow(10, total_dB / 20);
}

// Smooth parameter helper (one-pole)
function setParamSmooth(param, value, timeConst = 0.03) {
  const now = audioContext.currentTime;
  param.cancelScheduledValues(now);
  param.setTargetAtTime(value, now, timeConst);
}

/* ---------------- Sine generator with comp & safety ---------------- */
const minFreq = 40;
const maxFreq = 4500;

// Set this during your 1 kHz SPL calibration (e.g., 60â€“70 dB SPL at ear)
const BASE_GAIN_1KHZ = 0.2;

// Extra headroom to avoid clipping when bass is boosted
const HEADROOM = 0.7;

let compNode = null; // gentle safety compressor
function ensureCompressor(ctx) {
  if (compNode) return compNode;
  compNode = ctx.createDynamicsCompressor();
  compNode.threshold.setValueAtTime(-6, ctx.currentTime);
  compNode.knee.setValueAtTime(12, ctx.currentTime);
  compNode.ratio.setValueAtTime(2, ctx.currentTime);
  compNode.attack.setValueAtTime(0.01, ctx.currentTime);
  compNode.release.setValueAtTime(0.1, ctx.currentTime);
  return compNode;
}

function startSinewave(frequency) {
  if (experimentFinished) return;
  if (!audioContext || audioContext.state === 'suspended') return;

  if (osc) {
    try { osc.stop(); } catch(_) {}
    try { osc.disconnect(); } catch(_) {}
  }

  const freq = Math.max(minFreq, Math.min(maxFreq, frequency));

  osc = audioContext.createOscillator();
  osc.type = "sine";
  osc.frequency.value = freq;

  sineGain = audioContext.createGain();
  sineGain.gain.value = 0.0001; // start silent, ramp in

  const comp = ensureCompressor(audioContext);
  ensureMasterGain(audioContext);

  // Routing: osc -> gain -> comp -> destination
  // NEW: osc -> sineGain -> comp -> masterGain -> destination
  const master = ensureMasterGain(audioContext);
  osc.connect(sineGain).connect(comp).connect(master).connect(audioContext.destination);

  // ensure current user volume is applied
  applyUserVolume(USER_VOL_DB);  osc.start();

  // In startSinewave(), right after osc.start():
  enqueueEvent("sine_start", { freq_hz: freq });
  qStats && (qStats.sine_starts += 1);
  sineStartTs = performance.now();
  isSinePlaying = true; // you already set this later; keep one copy
  maybeStartConcurrent();

  const target = BASE_GAIN_1KHZ * HEADROOM * totalGainLinear(freq);
  setParamSmooth(sineGain.gain, target, 0.03);

  isSinePlaying = true;
}

function stopSinewave() {
  if (experimentFinished) return;
  enqueueEvent("sine_stop_called", {});
  if (sineStartTs !== null) {
    const dt = Math.round(performance.now() - sineStartTs);
    qStats && (qStats.sine_total_ms += dt);
    enqueueEvent("sine_end", { duration_ms: dt });
    sineStartTs = null;
    qStats && (qStats.sine_stops += 1);
  }
  maybeEndConcurrent("sine_stop");

  if (osc && sineGain) {
    const now = audioContext.currentTime;
    sineGain.gain.setTargetAtTime(0, now, 0.01); // ~10 ms tail
    try { osc.stop(now + 0.05); } catch(_) {}
    setTimeout(() => {
      try { osc.disconnect(); } catch(_) {}
      osc = null;
      isSinePlaying = false;
    }, 60);
  } else {
    isSinePlaying = false;
  }
}

/* ---------------- UI: slider -> sine with comp ---------------- */
sineSlider.addEventListener("mousedown", () => {
  const freq = sliderToFrequency(parseFloat(sineSlider.value));
  startSinewave(freq);
});

sineSlider.addEventListener("input", (event) => {
  const sliderVal = parseFloat(event.target.value);
  const freq = Math.max(minFreq, Math.min(maxFreq, sliderToFrequency(sliderVal)));

  // ğŸ‘‡ ADD THESE TWO LINES HERE
  if (qStats) qStats.sine_interactions += 1;
  enqueueEvent("sine_input", { raw_value: sliderVal, freq_hz: freq });

  if (!isSinePlaying) startSinewave(freq);

  if (osc) osc.frequency.value = freq;
  if (sineGain) {
    const target = BASE_GAIN_1KHZ * HEADROOM * totalGainLinear(freq);
    setParamSmooth(sineGain.gain, target, 0.02);
  }
});

// ğŸ‘‡ ADD THIS FUNCTION + BINDINGS
function logSineEndGesture() {
  const raw = parseFloat(sineSlider.value);
  const hz  = sliderToFrequency(raw);
  enqueueEvent("sine_interaction_end", { raw_value: raw, freq_hz: hz });
}

sineSlider.addEventListener("mouseup", logSineEndGesture);
sineSlider.addEventListener("touchend", logSineEndGesture);

sineSlider.addEventListener("mouseup", stopSinewave);
sineSlider.addEventListener("touchend", stopSinewave);

// Start button inside modal
// startBtn.addEventListener("click", () => {
//   initAudioContext();
//   sineSlider.disabled = false;
//   modal.style.display = "none";
//   // questionnaire.style.display = "flex";
// });

consentBtn.addEventListener("click", () => {
  consentModal.style.display = "none";
  modal.style.display = "flex";
});

questionnaireInfoBox.addEventListener("click", () => {
  infoBoxModal.style.display = "flex";
});

// Close modal when clicking outside modal content
infoBoxModal.addEventListener("click", (e) => {
  if (e.target === infoBoxModal) {
    infoBoxModal.style.display = "none";
  }
});

document.querySelectorAll('input[name="instrument"]').forEach((el) => {
  el.addEventListener("change", () => {
    const instrumentField = document.getElementById("instrumentNameField");
    if (el.value === "yes") {
      instrumentField.style.display = "block";
      document.getElementById("instrumentName").required = true;
    } else {
      instrumentField.style.display = "none";
      document.getElementById("instrumentName").value = "";
      document.getElementById("instrumentName").required = false;
    }
  });
});

document.querySelectorAll('input[name="knowPitch"]').forEach((el) => {
  el.addEventListener("change", () => {
    const explanation = document.getElementById("pitchExplanation");
    if (el.value === "no") {
      explanation.style.display = "block";
    } else {
      explanation.style.display = "none";
    }
  });
});

// ADD: hook up volume slider
const volumeSlider = document.getElementById("volumeSlider");
const volumeReadout = document.getElementById("volumeReadout");

if (volumeSlider) {
  volumeSlider.addEventListener("input", (e) => {
    const db = parseFloat(e.target.value);
    qStats && (qStats.vol_interactions += 1);
    enqueueEvent("vol_input", { vol_db: db });
    applyUserVolume(db);
  });
  volumeSlider.addEventListener("mousedown", () => {
    enqueueEvent("vol_start", { vol_db: parseFloat(volumeSlider.value) });
  });
  volumeSlider.addEventListener("mouseup", () => {
    enqueueEvent("vol_end", { vol_db: parseFloat(volumeSlider.value) });
  });
  volumeSlider.addEventListener("touchstart", () => {
    enqueueEvent("vol_start", { vol_db: parseFloat(volumeSlider.value) });
  });
  volumeSlider.addEventListener("touchend", () => {
    enqueueEvent("vol_end", { vol_db: parseFloat(volumeSlider.value) });
  });
}


const userForm = document.getElementById("userInfoForm");


// Î¥Ï€Î¿Î²Î¿Î»Î® Ï†ÏŒÏÎ¼Î±Ï‚
userForm.addEventListener("submit", async (e) => {
  e.preventDefault();

  // Ensure all required fields are valid
  if (!userForm.checkValidity()) {
    userForm.reportValidity(); // Show native browser validation UI
    return;
  }

  const userInfo = {
    session_id: sessionId,
    gender: document.getElementById("gender").value.trim(),
    age: parseInt(document.getElementById("age").value.trim(), 10),
    music_experience: document.getElementById("experience").value,
    years_experience: parseInt(document.getElementById("yearsExperience").value.trim(), 10),
    training_type: document.getElementById("trainingType").value,
    plays_instrument: document.querySelector('input[name="instrument"]:checked')?.value === "yes",
    instrument_name: document.getElementById("instrumentName").value.trim(),
    //equipment: document.getElementById("equipment").value,
    knows_pitch: document.querySelector('input[name="knowPitch"]:checked')?.value === "yes",
    hearing_condition: document.getElementById("hearing").value,
    absolute_pitch: document.querySelector('input[name="absolutePitch"]:checked')?.value === "yes",

    // âœ… NEW: consent fields
    consent: document.getElementById("consentCheckbox").checked,              // boolean
    consent_version: document.getElementById("consentVersion").value,         // tracks wording/version
    consent_timestamp: new Date().toISOString()                               // ISO time
  };


  try {
    const res = await fetch("save_indefinite_pitch_user_info", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(userInfo),
    });

    if (res.ok) {
      initAudioContext();
      sineSlider.disabled = false;
      introModal.style.display = "none";
      questionnaire.style.display = "flex";
      await fetchSounds(); // if needed
    } else {
      alert("Î Î±ÏÎ¿Ï…ÏƒÎ¹Î¬ÏƒÏ„Î·ÎºÎµ Ï€ÏÏŒÎ²Î»Î·Î¼Î± ÎºÎ±Ï„Î¬ Ï„Î·Î½ Î±Ï€Î¿Î¸Î®ÎºÎµÏ…ÏƒÎ· Ï„Ï‰Î½ ÏƒÏ„Î¿Î¹Ï‡ÎµÎ¯Ï‰Î½.");
    }
  } catch (err) {
    console.error("âŒ Error saving user info:", err);
    alert("Î£Ï†Î¬Î»Î¼Î± ÎºÎ±Ï„Î¬ Ï„Î·Î½ Î±Ï€Î¿ÏƒÏ„Î¿Î»Î® Ï„Ï‰Î½ ÏƒÏ„Î¿Î¹Ï‡ÎµÎ¯Ï‰Î½.");
  }
});


// Consent to submit

const consentCheckbox = document.getElementById("consentCheckbox");
const startBtnEl = document.getElementById("start-btn");
if (consentCheckbox && startBtnEl) {
  const updateStart = () => { startBtnEl.disabled = !consentCheckbox.checked; };
  consentCheckbox.addEventListener("change", updateStart);
  updateStart();
}


let sampleBuffer = null;
let sampleSource = null;
let isSamplePlaying = false;
let loopEnabled = false;

const noMatchButton = document.getElementById("no-match");
let noMatchClicked = false;

const loopToggleBtn = document.getElementById("loopToggleBtn");
const samplePlayBtn = document.getElementById("samplePlayBtn");

loopToggleBtn.addEventListener("click", () => {
  loopEnabled = !loopEnabled;
  loopToggleBtn.textContent = loopEnabled ? "Loop: ON" : "Loop: OFF";

  // log loop toggles
  qStats && (qStats.loop_toggles += 1);
  if (loopEnabled) qStats && (qStats.loop_on_count += 1);
  enqueueEvent("loop_toggle", { loop_enabled: loopEnabled });

  // If loop is being turned OFF while sample is playing, apply it
  if (!loopEnabled && isSamplePlaying && sampleSource) {
    sampleSource.loop = false;
    // Let it stop naturally on next end
  }
});

noMatchButton.addEventListener("click", () => {
  noMatchClicked = !noMatchClicked;

  qStats && (qStats.no_match_clicks += 1);
  enqueueEvent("no_match_toggle", { active: noMatchClicked });

  noMatchButton.classList.toggle("active", noMatchClicked);
  sineSlider.classList.toggle("slider-locked", noMatchClicked);
});


sineSlider.addEventListener("mousedown", () => {

  const raw = parseFloat(sineSlider.value);
  const hz  = sliderToFrequency(raw);
  enqueueEvent("sine_interaction_start", { raw_value: raw, freq_hz: hz });
  if (noMatchClicked) {
    // Reset no-match state
    noMatchClicked = false;
    noMatchButton.classList.remove("active");
    sineSlider.classList.remove("slider-locked");
  }
  if (qStats) qStats.sine_interactions += 1; // âœ… Î¼ÎµÏ„ÏÎ¬ÎµÎ¹ interaction

});

sineSlider.addEventListener("touchstart", () => {

  const raw = parseFloat(sineSlider.value);
  const hz  = sliderToFrequency(raw);
  enqueueEvent("sine_interaction_start", { raw_value: raw, freq_hz: hz });
  if (noMatchClicked) {
    noMatchClicked = false;
    noMatchButton.classList.remove("active");
    sineSlider.classList.remove("slider-locked");
  }
  if (qStats) qStats.sine_interactions += 1; // âœ… Î¼ÎµÏ„ÏÎ¬ÎµÎ¹ interaction

});





// Load the sample once after AudioContext is allowed
function loadSample(url) {
  return fetch(url)
    .then(response => response.arrayBuffer())
    .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
    .then(decodedData => {
      sampleBuffer = decodedData;
    });
}

// Play or stop sample
function toggleSample() {
  if (experimentFinished) return;
  if (!audioContext || !sampleBuffer) return;

  if (isSamplePlaying) {
    stopSample();
  } else {
    playSample();
  }
}

const sampleIcon = document.getElementById("sampleIcon");

function playSample() {
  if (experimentFinished) return;
  // At the start of playSample(), right before/after creating the source:
  enqueueEvent("sample_play_start", { loop: loopEnabled });
  sampleStartTs = performance.now();

  if (!audioContext || !sampleBuffer) return;

  // If already playing, stop it
  if (isSamplePlaying) {
    stopSample();
    return;
  }

  sampleSource = audioContext.createBufferSource();
  sampleSource.buffer = sampleBuffer;
  sampleSource.loop = loopEnabled;
  sampleSource.connect(audioContext.destination);

  sampleSource.onended = () => {
    if (sampleStartTs !== null) {
      const dt = Math.round(performance.now() - sampleStartTs);
      qStats && (qStats.sample_total_ms += dt);
      enqueueEvent("sample_play_end", { natural: true, duration_ms: dt });
      sampleStartTs = null;
      qStats && (qStats.sample_stops += 1);
    }
    maybeEndConcurrent("sample_stop");
    isSamplePlaying = false;
    sampleSource = null;
    if (sampleIcon) {
      sampleIcon.textContent = "â–¶"; // reset icon
      sampleIcon.style.fontSize = "20px";
    }
  };

  sampleSource.start();
  isSamplePlaying = true;
  if (sampleIcon) {
    sampleIcon.textContent = "â– "; // show stop iconâ¹
    sampleIcon.style.fontSize = "20px";

  }

  // After you set isSamplePlaying = true and icon updates:
  maybeStartConcurrent();

}

function stopSample() {
  if (experimentFinished) return;
  // At the very start of stopSample():
  enqueueEvent("sample_stop_called", {});
  if (sampleStartTs !== null) {
    const dt = Math.round(performance.now() - sampleStartTs);
    qStats && (qStats.sample_total_ms += dt);
    enqueueEvent("sample_play_end", { natural: false, duration_ms: dt });
    sampleStartTs = null;
    qStats && (qStats.sample_stops += 1);
  }
  maybeEndConcurrent("sample_stop");
  if (sampleSource) {
    sampleSource.stop();
    sampleSource.disconnect();
    sampleSource = null;
    isSamplePlaying = false;
    if (sampleIcon) {
      sampleIcon.textContent = "â–¶"; // reset icon
      sampleIcon.style.fontSize = "20px";
    }
  }
}


// Load the sample after user clicks "Start"
// startBtn.addEventListener("click", async () => {
//   initAudioContext();
//   sineSlider.disabled = false;
//   modal.style.display = "none";
//   await fetchSoundList(); // triggers random sound list and starts 1st sound
// });

// ğŸ” Use both hotkey & click to toggle
document.addEventListener("keydown", (e) => {
  if (e.key === "a" || e.key === "A") {
    enqueueEvent("sample_play_button", { source: "key_A", action: isSamplePlaying ? "request_stop" : "request_play" });
    if (!isSamplePlaying && qStats) qStats.sample_play_presses += 1;
    toggleSample();
  }
});

samplePlayBtn.addEventListener("click", () => {

  enqueueEvent("sample_play_button", { source: "click", action: isSamplePlaying ? "request_stop" : "request_play" });
  if (!isSamplePlaying && qStats) qStats.sample_play_presses += 1;
  toggleSample();
});



let soundList = [];
let currentSoundIndex = 0;

async function fetchSoundList() {
  const res = await fetch("get_sounds");
  soundList = await res.json();
  currentSoundIndex = 0;
  loadCurrentSound();
}

let isTrainingPhase = true; // ğŸ‘‰ Î¾ÎµÎºÎ¹Î½Î¬Î¼Îµ Î¼Îµ training

async function fetchSounds() {
  const endpoint = isTrainingPhase
    ? "get_sounds_training"
    : "get_sounds";

  const res = await fetch(endpoint);
  soundList = await res.json();
  currentSoundIndex = 0;
  loadCurrentSound();
}

function updateSoundProgressDisplay() {
  const box = document.getElementById("soundProgressBox");
  const label = isTrainingPhase ? "Î•Î½Î´ÎµÎ¹ÎºÏ„Î¹ÎºÏŒÏ‚ Î‰Ï‡Î¿Ï‚" : "Î‰Ï‡Î¿Ï‚";
  box.textContent = `${label} ${currentSoundIndex + 1} Î±Ï€ÏŒ ${soundList.length}`;

  if (isTrainingPhase) {
    box.classList.add("training-active");
  } else {
    box.classList.remove("training-active");
  }
}

async function loadCurrentSound() {
  const file = soundList[currentSoundIndex];
  const folder = isTrainingPhase ? "indefinite_pitch/training" : "indefinite_pitch";
  const response = await fetch(`/static/${folder}/${file}`);
  const buffer = await response.arrayBuffer();
  sampleBuffer = await audioContext.decodeAudioData(buffer);
  updateSoundProgressDisplay();

  resetQuestionStats();   // per-question counters/durations reset
  startGestureCapture();  // start 250 ms sampling for this question
  const w = document.getElementById("answerWarning");
  if (w) w.style.display = "none";
  enqueueEvent("question_loaded", {});
}




document.getElementById("next").addEventListener("click", async () => {
  const currentSound = soundList[currentSoundIndex];
  const pressedPlay = qStats && qStats.sample_play_presses > 0;
  const sineMoved   = qStats && qStats.sine_interactions > 0;
  const hasNoMatch  = noMatchClicked;

  // --- RULE 1: MUST have pressed play at least once ---
  if (!pressedPlay) {
    enqueueEvent("warn_no_play_pressed", {});
    alert("Î”ÎµÎ½ Î­Ï‡ÎµÏ„Îµ Ï€Î±Ï„Î®ÏƒÎµÎ¹ Ï„Î¿ ÎºÎ¿Ï…Î¼Ï€Î¯ Î±Î½Î±Ï€Î±ÏÎ±Î³Ï‰Î³Î®Ï‚ Ï„Î¿Ï… Î´ÎµÎ¯Î³Î¼Î±Ï„Î¿Ï‚. Î Î±ÏÎ±ÎºÎ±Î»Ï Î±ÎºÎ¿ÏÏƒÏ„Îµ Ï€ÏÏÏ„Î± Ï„Î¿Î½ Î®Ï‡Î¿ Ï€ÏÎ¹Î½ ÏƒÏ…Î½ÎµÏ‡Î¯ÏƒÎµÏ„Îµ.");
    return; // âŒ Î‘ÎºÏ…ÏÏÎ½ÎµÎ¹ Ï‡Ï‰ÏÎ¯Ï‚ confirm
  }

  // --- RULE 2: Must either slide or choose no-match ---
  const allowed = sineMoved || hasNoMatch;
  if (!allowed) {
    enqueueEvent("warn_no_mapping_interaction", {});
    const ok = window.confirm(
      "Î”ÎµÎ½ Î­Ï‡ÎµÏ„Îµ Î±Î½Ï„Î¹ÏƒÏ„Î¿Î¹Ï‡Î¯ÏƒÎµÎ¹ Ï„Î¿ pitch (Î¿ÏÏ„Îµ Î¼Î­ÏƒÏ‰ slider Î¿ÏÏ„Îµ Î¼Îµ Ï„Î·Î½ ÎµÏ€Î¹Î»Î¿Î³Î® Â«Î”ÎµÎ½ Î²ÏÎ¯ÏƒÎºÏ‰ Î±Î½Ï„Î¹ÏƒÏ„Î¿Î¯Ï‡Î¹ÏƒÎ·Â»).\nÎ•Î¯ÏƒÏ„Îµ ÏƒÎ¯Î³Î¿Ï…ÏÎ¿Î¹ ÏŒÏ„Î¹ Î¸Î­Î»ÎµÏ„Îµ Î½Î± ÏƒÏ…Î½ÎµÏ‡Î¯ÏƒÎµÏ„Îµ;"
    );
    if (!ok) return;
  }
  const slider_raw = parseFloat(sineSlider.value);                 // 0..1000 UI value
  const frequency_hz = noMatchClicked ? 0 : sliderToFrequency(slider_raw);
  const user_vol_db = typeof USER_VOL_DB === "number" ? USER_VOL_DB : 0;

  const responseData = {
    session_id: sessionId,
    sound: currentSound,
    training: isTrainingPhase,                                     // false here (still useful)
    response: {
      slider_raw,                                                  // keep raw for reproducibility
      frequency_hz,                                                // âœ… the actual Hz
      cannotMapPitch: noMatchClicked,
      user_vol_db,                                                 // context
      timestamp: new Date().toISOString()
    },
  };

  await fetch("save_responses_indefinite_pitch", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(responseData),
  });

  stopSample();

  // Finalize any running durations
  if (sampleStartTs !== null) {
    const dt = Math.round(performance.now() - sampleStartTs);
    qStats && (qStats.sample_total_ms += dt);
    enqueueEvent("sample_play_end", { duration_ms: dt, forced: true });
    sampleStartTs = null;
  }
  if (sineStartTs !== null) {
    const dt = Math.round(performance.now() - sineStartTs);
    qStats && (qStats.sine_total_ms += dt);
    enqueueEvent("sine_end", { duration_ms: dt, forced: true });
    sineStartTs = null;
  }
  maybeEndConcurrent("question_advance");

  // Emit a compact summary for this question
  enqueueEvent("question_summary", { stats: qStats });

  // Mark boundary, stop samplers, reset volume
  enqueueEvent("question_advance", { action: "leaving_question" });
  stopGestureCapture();
  resetVolumeToCalibrated();

  // Move to next question id
  currentQuestionId += 1;

  // ADD: return user volume to calibrated baseline for each new question
  resetVolumeToCalibrated();

  currentSoundIndex++;
  sineSlider.value = 440;

  if (currentSoundIndex >= soundList.length) {
    if (isTrainingPhase) {
      // ğŸ‘‰ Î•ÎºÏ€Î±Î¯Î´ÎµÏ…ÏƒÎ· Ï„Î­Î»Î¿Ï‚ â†’ Î¾ÎµÎºÎ¹Î½Î¬ÎµÎ¹ Ï„Î¿ Ï€ÎµÎ¯ÏÎ±Î¼Î±
      isTrainingPhase = false;
      currentSoundIndex = 0;
      await fetchSounds(); // ÎºÎ±Î½Î¿Î½Î¹ÎºÎ¬ stimuli
      document.getElementById("next").textContent = "Î•Ï€ÏŒÎ¼ÎµÎ½Î¿Ï‚ Î‰Ï‡Î¿Ï‚";
      return;
    }

    // ğŸ‘‰ Î¤Î­Î»Î¿Ï‚ ÎºÎ±Î½Î¿Î½Î¹ÎºÎ¿Ï Ï€ÎµÎ¹ÏÎ¬Î¼Î±Ï„Î¿Ï‚
    await finishExperiment(); // <- new function below
    document.getElementById("thankYouModal").style.display = "flex";
  } else {
    if (!isTrainingPhase && currentSoundIndex === soundList.length - 1) {
      document.getElementById("next").textContent = "ÎŸÏÎ¹ÏƒÏ„Î¹ÎºÎ® Ï…Ï€Î¿Î²Î¿Î»Î®";
    }
    await loadCurrentSound();
    stopSample();
    isSamplePlaying = false;
  }

  // Reset UI state
  noMatchClicked = false;
  noMatchButton?.classList.remove("active");
  sineSlider?.classList.remove("slider-locked");
});



function sliderToFrequency(value) {
  const minFreq = 40;
  const maxFreq = 4500;
  const minLog = Math.log10(minFreq);
  const maxLog = Math.log10(maxFreq);
  const scale = value / 1000;
  const logFreq = minLog + (maxLog - minLog) * scale;
  return Math.pow(10, logFreq);
}

function frequencyToSlider(freq) {
  const minFreq = 40;
  const maxFreq = 4500;
  const minLog = Math.log10(minFreq);
  const maxLog = Math.log10(maxFreq);
  const logFreq = Math.log10(freq);
  return ((logFreq - minLog) / (maxLog - minLog)) * 1000;
}

sineSlider.value = frequencyToSlider(440).toFixed(0); // Set slider to correspond to 440 Hz

async function finishExperiment() {
  if (experimentFinished) return;
  experimentFinished = true;

  try { stopGestureCapture(); } catch(_) {}
  try { stopSample(); } catch(_) {}
  try { stopSinewave(); } catch(_) {}

  // disable UI so user canâ€™t interact
  try {
    sineSlider.disabled = true;
    const volumeSliderEl = document.getElementById("volumeSlider");
    if (volumeSliderEl) volumeSliderEl.disabled = true;
    const nextBtn = document.getElementById("next");
    if (nextBtn) nextBtn.disabled = true;
    const playBtn = document.getElementById("samplePlayBtn");
    if (playBtn) playBtn.disabled = true;
    const loopBtn = document.getElementById("loopToggleBtn");
    if (loopBtn) loopBtn.disabled = true;
    const noMatchBtn = document.getElementById("no-match");
    if (noMatchBtn) noMatchBtn.disabled = true;
  } catch(_) {}

  // finalize durations if still running (mirrors your Next-handler logic)
  if (typeof sampleStartTs === "number" && sampleStartTs !== null) {
    const dt = Math.round(performance.now() - sampleStartTs);
    if (qStats) qStats.sample_total_ms += dt;
    enqueueEvent("sample_play_end", { duration_ms: dt, forced: true });
    sampleStartTs = null;
  }
  if (typeof sineStartTs === "number" && sineStartTs !== null) {
    const dt = Math.round(performance.now() - sineStartTs);
    if (qStats) qStats.sine_total_ms += dt;
    enqueueEvent("sine_end", { duration_ms: dt, forced: true });
    sineStartTs = null;
  }
  maybeEndConcurrent("experiment_finish");

  // emit a last summary if youâ€™re mid-question
  if (qStats) {
    enqueueEvent("question_summary", { stats: qStats });
  }
  enqueueEvent("experiment_finished", {});

  // final flush to server
  await flushInteractions();
}

document.addEventListener("visibilitychange", () => {
  if (document.visibilityState === "hidden") {
    stopGestureCapture();
    flushInteractions();
  } else {
    if (!experimentFinished && soundList?.length && document.getElementById("thankYouModal")?.style.display !== "flex") {
      startGestureCapture();
    }
  }
});


</script>

</body>
</html>
